(ns lindsey.base)
;;
;; Load by doing:
;;
;; (defn load-lindsey [f] (binding [*current-reader* :lindsey-reader] (load-file f)))
;; (defn read-lindsey [s] (binding [*current-reader* :lindsey-reader] (read-string s)))
;; (load-lindsey "base.lin")
;;

function foo
  "Simple function definition"
  [a]
  let [b = 24, c = 42]
    +(a b c)
  end
end

function simple-if
  "Single-branch if"
  [num]
  if pos?(num)
    println("Branch 1")
    println("It's positive!")
  end
end

function medium-if
  "If-else"
  [num]
  if pos?(num)
    println("Branch 1")
    println("It's positive!")
  else
    println("Branch 2")
    println("It's negative or zero!")
  end
end

function complex-if
  "If and elseif and else"
  [num]
  if pos?(num)
    println("Branch 1")
    println("It's positive!")
  elseif neg?(num)
    println("Branch 2")
    println("It's negative!")
  else
    println("Branch 3")
    println("It's zero!")
  end
end

function really-complex-if
  "Nested if's"
  [num]
  if pos?(num)
    println("Branch 1")
    println("It's positive!")
    if >(num, 1000)
      println("Branch 1a")
      println("It's big!")
    else
      println("Branch 1b")
      println("It's small!")
    end
  elseif neg?(num)
    println("Branch 2")
    println("It's negative!")
    if <(num, -1000)
      println("Branch 2a")
      println("It's really small!")
    else
      println("Branch 2b")
      println("It's just kinda small")
    end
  else
    println("Branch 3")
    println("It's zero!")
  end
end

function multi-arity
  "Handle multiple arity correctly"
  arity [x]
    (* x 3)
  end
  arity [x y]
    (* x y)
  end
end

function method-call
  "Instance method call example"
  [s]
  s.substring(0,3)
end

function random-uuid
  "A static method call to UUID.randomUUID()"
  []
  java.util.UUID/randomUUID()
end

record Employee [name title salary] end

;; (defprotocol Sellable
;;   (calculate-tax [this base rate]))
protocol Sellable
  proto-method calculate-tax [this base rate] end
end

record Product [a b]
  extends Sellable
    impl calculate-tax [this base rate]
      println("Calculate taxes!")
      *(base, rate)
    end
  end
end

multi validate juxt(:lang, :type) end

method validate ["English" "greeting"]
  [m]
  let [phrase = get(m, :phrase),
       lc = clojure.string/lower-case
       greetings = #{"hello" "good morning" "good afternoon" "good evening"}]
    greetings(lc(phrase))
  end
end
