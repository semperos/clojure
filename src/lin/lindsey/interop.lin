ns lindsey.interop
  require-ns [clojure.string :refer [upper-case]] end
end

java-class SimpleClass
  java-method main [& args]
    println("Embedded -main for SimpleClass")
  end

  java-method ^String noArgs []
    "wowza!"
  end

  java-method ^Long multiply [^Long x]
    *(x, 42)
  end

  java-method ^{:static true}
    staticCharge []
      upper-case("Static charge complete.")
  end
end

java-class StringIterator implements java.util.Iterator

  java-constructor ^{:super-constructors {[String] []}}
    init [^String s]
    ;; TODO We parse this defn anyway, store the
    ;; argslist ourselves and just make the ctor here
    ;; return the value of the state. Would need to handle
    ;; multiple arities, too.
    [[] atom({:index 0 :s s})]
  end

  java-impl ^Boolean hasNext []
    let [{:keys [s index]} = deref(this.state())]
      <(index, count(s))
    end
  end

  java-impl ^Character next []
    let [{:keys [s index]} = deref(this.state())
         ch = s.charAt(index)]
      swap!(this.state(), assoc, :index, inc(index))
      ch
    end
  end

end
